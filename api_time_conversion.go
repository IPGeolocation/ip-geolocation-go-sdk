/*
IPGeolocation.io - IP intelligence products

Ipgeolocation provides a set of APIs to make ip based decisions.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ipgeolocationsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type TimeConversionAPI interface {

	/*
	ConvertTimeBetweenTimezones Method for ConvertTimeBetweenTimezones

	You can convert a timestamp provided as a query paramter time from one time zone to another time zone.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiConvertTimeBetweenTimezonesRequest
	*/
	ConvertTimeBetweenTimezones(ctx context.Context) ApiConvertTimeBetweenTimezonesRequest

	// ConvertTimeBetweenTimezonesExecute executes the request
	//  @return TimeConversionResponse
	ConvertTimeBetweenTimezonesExecute(r ApiConvertTimeBetweenTimezonesRequest) (*TimeConversionResponse, *http.Response, error)
}

// TimeConversionAPIService TimeConversionAPI service
type TimeConversionAPIService service

type ApiConvertTimeBetweenTimezonesRequest struct {
	ctx context.Context
	ApiService TimeConversionAPI
	time *string
	tzFrom *string
	tzTo *string
	latFrom *float32
	longFrom *float32
	latTo *float32
	longTo *float32
	locationFrom *string
	locationTo *string
	icaoFrom *string
	icaoTo *string
	iataFrom *string
	iataTo *string
	locodeFrom *string
	locodeTo *string
}

// time parameter takes the input in the following two formats: i) &#39;yyyy-MM-dd HH:mm&#39;, and ii) &#39;yyyy-MM-dd HH:mm:ss&#39;. This parameter is optional and you can omit it to convert the current time between two coordinates, time zones or locations.
func (r ApiConvertTimeBetweenTimezonesRequest) Time(time string) ApiConvertTimeBetweenTimezonesRequest {
	r.time = &time
	return r
}

// timezone to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) TzFrom(tzFrom string) ApiConvertTimeBetweenTimezonesRequest {
	r.tzFrom = &tzFrom
	return r
}

// timezone to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) TzTo(tzTo string) ApiConvertTimeBetweenTimezonesRequest {
	r.tzTo = &tzTo
	return r
}

// latitude to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) LatFrom(latFrom float32) ApiConvertTimeBetweenTimezonesRequest {
	r.latFrom = &latFrom
	return r
}

// longitude to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) LongFrom(longFrom float32) ApiConvertTimeBetweenTimezonesRequest {
	r.longFrom = &longFrom
	return r
}

// latitude to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) LatTo(latTo float32) ApiConvertTimeBetweenTimezonesRequest {
	r.latTo = &latTo
	return r
}

// longitude to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) LongTo(longTo float32) ApiConvertTimeBetweenTimezonesRequest {
	r.longTo = &longTo
	return r
}

// location to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) LocationFrom(locationFrom string) ApiConvertTimeBetweenTimezonesRequest {
	r.locationFrom = &locationFrom
	return r
}

// location to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) LocationTo(locationTo string) ApiConvertTimeBetweenTimezonesRequest {
	r.locationTo = &locationTo
	return r
}

// location to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) IcaoFrom(icaoFrom string) ApiConvertTimeBetweenTimezonesRequest {
	r.icaoFrom = &icaoFrom
	return r
}

// location to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) IcaoTo(icaoTo string) ApiConvertTimeBetweenTimezonesRequest {
	r.icaoTo = &icaoTo
	return r
}

// location to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) IataFrom(iataFrom string) ApiConvertTimeBetweenTimezonesRequest {
	r.iataFrom = &iataFrom
	return r
}

// location to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) IataTo(iataTo string) ApiConvertTimeBetweenTimezonesRequest {
	r.iataTo = &iataTo
	return r
}

// location to convert from
func (r ApiConvertTimeBetweenTimezonesRequest) LocodeFrom(locodeFrom string) ApiConvertTimeBetweenTimezonesRequest {
	r.locodeFrom = &locodeFrom
	return r
}

// location to convert to
func (r ApiConvertTimeBetweenTimezonesRequest) LocodeTo(locodeTo string) ApiConvertTimeBetweenTimezonesRequest {
	r.locodeTo = &locodeTo
	return r
}

func (r ApiConvertTimeBetweenTimezonesRequest) Execute() (*TimeConversionResponse, *http.Response, error) {
	return r.ApiService.ConvertTimeBetweenTimezonesExecute(r)
}

/*
ConvertTimeBetweenTimezones Method for ConvertTimeBetweenTimezones

You can convert a timestamp provided as a query paramter time from one time zone to another time zone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConvertTimeBetweenTimezonesRequest
*/
func (a *TimeConversionAPIService) ConvertTimeBetweenTimezones(ctx context.Context) ApiConvertTimeBetweenTimezonesRequest {
	return ApiConvertTimeBetweenTimezonesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TimeConversionResponse
func (a *TimeConversionAPIService) ConvertTimeBetweenTimezonesExecute(r ApiConvertTimeBetweenTimezonesRequest) (*TimeConversionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimeConversionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeConversionAPIService.ConvertTimeBetweenTimezones")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timezone/convert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "form", "")
	}
	if r.tzFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tz_from", r.tzFrom, "form", "")
	}
	if r.tzTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tz_to", r.tzTo, "form", "")
	}
	if r.latFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lat_from", r.latFrom, "form", "")
	}
	if r.longFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "long_from", r.longFrom, "form", "")
	}
	if r.latTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lat_to", r.latTo, "form", "")
	}
	if r.longTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "long_to", r.longTo, "form", "")
	}
	if r.locationFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location_from", r.locationFrom, "form", "")
	}
	if r.locationTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location_to", r.locationTo, "form", "")
	}
	if r.icaoFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "icao_from", r.icaoFrom, "form", "")
	}
	if r.icaoTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "icao_to", r.icaoTo, "form", "")
	}
	if r.iataFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iata_from", r.iataFrom, "form", "")
	}
	if r.iataTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "iata_to", r.iataTo, "form", "")
	}
	if r.locodeFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locode_from", r.locodeFrom, "form", "")
	}
	if r.locodeTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locode_to", r.locodeTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apiKey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 499 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
